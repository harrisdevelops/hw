#1. The Singleton design pattern ensures that only one instance of a class exists throughout the entire program runtime.
→ Its goal is to provide a single global access point to that instance.

Two Implementation Modes

Lazy Loading (on-demand):
The instance is created only when first needed.
→ Requires a null check before instantiation.
→ The instance cannot be final, since it’s assigned later.

Eager Loading (pre-initialized):
The instance is created at class loading time (usually in a static block).
→ No null check needed.
→ The instance can be declared final because it’s immutable and initialized once.

Access Control

The constructor is private → prevents external instantiation.

A public static getInstance() method provides controlled access.

External code cannot use new to create another object.

You should never expose the instance field directly (no public access).
→ Always access through get/set methods to maintain encapsulation.

Static & Memory Handling

The static instance and class template are stored in the JVM’s method area,
while created objects go into the heap.

The static block (if used) runs once when the class loads, perfect for eager loading.

Best Practices

Use lazy loading if the object is large or rarely used.

Use eager loading if the object is small or frequently used.

The final keyword ensures immutability (used only in eager mode).

Avoid modifying instance references after creation.

#2. Factory Design Pattern can be deduced:

Purpose:
To centralize object creation logic for related types, providing a single point (the factory) to handle instantiation based on input (e.g., payment type).

Core Components:
Interface (e.g., Payment):

Defines a common method (e.g., pay(double money)) that all payment types must implement.

Ensures consistency across different implementations.

Concrete Implementations:

Classes (e.g., PayPalPayment, CreditCardPayment) that implement the interface and provide specific behavior for the pay method.

Factory Class (e.g., PaymentFactory):

Contains a static method (e.g., getPayment(String type)) to create and return the appropriate payment object based on the input type.

Uses conditional logic (e.g., if-else or switch) to determine which concrete class to instantiate.

Key Implementation Details:
The factory method is typically static to avoid unnecessary object creation, especially when the factory is stateless.

The pattern encapsulates object creation, allowing the client (e.g., PaymentService) to use objects without knowing their specific classes.

Only the main class (e.g., PaymentService) is public; other classes (factory, implementations) are package-private, adhering to Java file structure rules.

Example Workflow:
Client calls PaymentFactory.getPayment("creditcard").

Factory returns a CreditCardPayment instance.

Client invokes payment.pay(amount) without needing to know the underlying implementation.

Additional Java Concepts Linked:
Interfaces vs. Classes: Interfaces define contracts; classes provide implementations.

Static Methods: Used in the factory to enable direct class-level access.

Exception Handling: Factory methods may throw exceptions (e.g., for invalid types), which can be handled using try-catch or propagated with throws.

Autoboxing/Auto-unboxing: Mechanism to convert between primitive types (e.g., double) and their wrapper classes (e.g., Double).

#3. Java's data structures are organized under two distinct hierarchies: the Collection Framework and the Map interface

Collection Framework (Under Iterable):

Purpose: Represents a group of objects treated as a single unit, known as elements.

Key Characteristic: Because it extends Iterable, all Collection types can be directly iterated over using for-each loops or iterators.

Main Sub-Interfaces: List, Set, Queue/Deque.

Map Framework (Separate from Collection):

Purpose: Represents a group of key-value pairs, where each key is unique.

Key Characteristic: It is NOT a subtype of Collection or Iterable. Therefore, you cannot directly iterate over a Map itself.

How to Iterate: You must first convert a Map into a Collection view (e.g., map.keySet(), map.values(), or map.entrySet()) and then iterate over that collection.

Relationships and "When to Use Which" Within the Collection Framework
The document emphasizes answering with "When to use which?" to demonstrate practical experience. Here is a breakdown of the critical data structures based on their relationships and use cases.

1. The List Interface (Ordered, Allows Duplicates)
Lists maintain the insertion order of elements.

ArrayList vs. LinkedList:

Relationship: Both implement the List interface but with different underlying data structures (dynamic array vs. doubly-linked list).

When to use ArrayList:

Use Case: Most common and general-purpose List.

Reason: Excellent for random access (getting an element by index get(i) is very fast - O(1)).

Trade-off: Adding or removing elements from anywhere but the end can be slow (may require shifting elements - O(n)).

When to use LinkedList:

Use Case: When you frequently add or remove elements from the beginning or middle of the list.

Reason: Adding/removing elements is fast (O(1)) once the position is found, as it only requires changing node pointers.

Trade-off: Random access is slow (O(n)), as it requires traversing the list from the start or end.

2. The Set Interface (Unique Elements Only)
Sets do not allow duplicate elements. The concept of "order" differentiates them.

HashSet vs. LinkedHashSet:

Relationship: LinkedHashSet is a subclass of HashSet. It maintains a hash table for uniqueness but adds a doubly-linked list running through all entries.

When to use HashSet:

Use Case: When you need to ensure uniqueness and do not care about the order in which elements are stored or iterated.

Reason: It offers the fastest performance for add, remove, and contains operations (O(1)).

When to use LinkedHashSet:

Use Case: When you need a Set that also maintains the insertion order of elements.

Reason: It provides the performance of a HashSet while giving predictable, order-based iteration.

3. The Queue/Deque Interface (FIFO/LIFO)
Designed for holding elements prior to processing.

Relationship: Deque (Double Ended Queue) extends the Queue interface, allowing insertion and removal from both ends.

When to use a Queue (e.g., LinkedList, PriorityQueue):

Use Case: For tasks like job scheduling, message passing, or implementing BFS algorithms (First-In-First-Out).

When to use a Deque (e.g., ArrayDeque):

Use Case: When you need a stack (LIFO) or a queue that can operate from both ends. ArrayDeque is often more efficient than Stack (a legacy class) or LinkedList for queue/deque operations.

BlockingQueue:

Use Case: Specifically for multi-threaded programming. It provides operations that wait for the queue to become non-empty when retrieving an element or wait for space to become available when storing an element.

Legacy Classes (A Note on Thread Safety)
The document mentions "legacy classes" that are thread-safe but low-performance.

Relationship: These are the older, synchronized implementations like Vector and Hashtable.

When to use (or not use): They are generally deprecated. If you need thread-safe collections, prefer the modern implementations in the java.util.concurrent package (e.g., ConcurrentHashMap, CopyOnWriteArrayList) which offer better performance through more sophisticated locking mechanisms.
