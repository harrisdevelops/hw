#1. Jdk versions + key features
- Java evolves through JDK milestones — each release adds stability or innovation.
The Java Development Kit (JDK) defines both the compiler and runtime ecosystem for the Java language.
Each major version not only introduces new syntax or APIs but also reflects Oracle’s engineering direction for performance, concurrency, and developer productivity.
- JDK 8: the modern baseline.
* Became the most stable and widely adopted version by 2018, roughly four years after release.
* Introduced key modern language features such as Lambda expressions, Streams API, and CompletableFuture, which revolutionized asynchronous and functional programming.
* Most enterprise frameworks (e.g., older Spring versions) standardized on JDK 8 as the long-term foundation.
- JDK 11: performance and observability milestone.
* Marked a major LTS (Long-Term Support) release after JDK 8.
* Brought Flight Recorder (previously a paid feature in OracleJDK) into the open-source distribution, allowing developers to monitor performance metrics freely.
* Represented Oracle’s shift toward open tooling and Java’s transition into modularization and runtime efficiency.
- JDK 17: the current enterprise standard.
* Widely adopted because Spring 6 and Spring Boot 3.0 require JDK 17 for backward compatibility and module compliance.
* Improved pattern matching, sealed classes, and stronger memory model stability.
* Considered the current stable LTS release for production-grade Java applications.
- JDK 19 & 21: the era of Virtual Threads (Project Loom).
* JDK 19: introduced Virtual Threads as an experimental feature, aiming to simplify concurrency by providing lightweight, user-mode threads.
* JDK 21: made Virtual Threads stable, removing the experimental flag and positioning them as the next-generation alternative to traditional thread pools.
* These versions redefine Java’s concurrency model — shifting from blocking threads to millions of concurrent lightweight tasks.
- Best practice: use stable LTS releases for enterprise deployment.
* Although newer versions (e.g., 21+) introduce innovations, they may lack long-term stability.
* Industry consensus favors using LTS versions (JDK 8, 11, 17) until the latest innovations mature.
* Developers should be familiar with these milestone transitions and articulate how new features improve scalability and developer ergonomics.

#2. Thread creation 
- Multithreading enables concurrent execution within a single process.
* A thread is the smallest unit of CPU execution within a process.
* Java’s concurrency model builds upon the Thread class and the Runnable / Callable interfaces.
* Each thread has its own stack but shares the heap memory with other threads — enabling communication but also potential data conflicts.
- Java provides multiple mechanisms for thread creation.
(a) Extending the Thread class
Example:1)Simplest approach; run() defines the task logic; 2) Not ideal for inheritance-heavy systems since Java only allows single inheritance.
class MyThread extends Thread {
    public void run() {
        System.out.println("Running via Thread subclass");
    }
}
new MyThread().start();
(b) Implementing the Runnable interface
Example:1)Decouples task logic from thread management 2)Enables composition: a single task can be executed by multiple threads 3)Became the preferred design since Java 1.5
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Running via Runnable interface");
    }
}
new Thread(new MyRunnable()).start();
(c) Using the Callable interface (from java.util.concurrent)
Example:1)Similar to Runnable but returns a result and can throw checked exceptions 2) Works with Future or ExecutorService for asynchronous computation.
class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 42;
    }
}
Future<Integer> result = Executors.newSingleThreadExecutor().submit(new MyCallable());
- Thread execution and lifecycle are managed via the start() method.
* Calling start() triggers a new thread managed by the JVM scheduler.
* Directly invoking run() executes on the main thread, not a new one.
* The thread transitions through states: New → Runnable → Running → Blocked/Waiting → Terminated.
- Evolution toward managed thread pools and async frameworks.
* Direct thread creation is costly due to OS-level context switching.
* Modern Java provides thread pools (ExecutorService) to reuse threads efficiently.
* Later, CompletableFuture and Virtual Threads (JDK 19+) abstract away manual thread creation.
* The model evolved from manual threading → task-based execution → structured concurrency.
- Best practice: delegate thread creation to high-level APIs.
* Use Executors, ForkJoinPool, or Virtual Threads instead of raw Thread for scalability.
* Avoid creating large numbers of unmanaged threads — use thread pooling and asynchronous design.
* Always ensure thread safety when shared data is accessed across threads.

#3. Thread lifecycle 
- Threads in Java follow a well-defined lifecycle governed by the JVM scheduler.
* A thread represents a single sequential flow of control within a process.
* The JVM thread scheduler manages transitions between states based on CPU availability, synchronization locks, or waiting conditions.
* Understanding these states is essential for diagnosing concurrency issues, optimizing performance, and ensuring thread safety.
- The Thread Lifecycle consists of distinct, JVM-defined states:
(a) NEW (Created but not started)
* The thread object is instantiated using new Thread().
* It exists in memory but is not yet scheduled for execution.
Example:
Thread t = new Thread();
// Still in NEW state
(b) RUNNABLE (Ready to run)
* Invoking t.start() transitions the thread to RUNNABLE.
* The thread is now eligible for execution by the JVM scheduler.
* This state covers both “ready to run” and “currently running” (JVM may switch between them).
(c) RUNNING (Actively executing)
* The CPU executes the thread’s run() method instructions.
* The thread remains in this state until it either completes, waits, or blocks.
* JVM’s time-slicing determines when and how long a thread executes.
(d) BLOCKED / WAITING (Paused execution)
* The thread is temporarily inactive because it’s waiting for a resource or signal:
-- BLOCKED: waiting for a monitor lock (e.g., entering a synchronized block).
-- WAITING: waiting for another thread’s notification (wait() / notify()).
-- TIMED_WAITING: waiting for a specific time (e.g., sleep(ms), join(ms)).
* The thread automatically transitions back to RUNNABLE once the condition clears.
(e) TERMINATED (Dead / Finished)
* The thread has completed its run() method or encountered an unhandled exception.
* Once TERMINATED, a thread cannot be restarted — calling start() again will throw IllegalThreadStateException.
- Thread state transitions are determined by code behavior and system scheduling.
* start() → moves from NEW → RUNNABLE.
* JVM scheduling → alternates between RUNNABLE ↔ RUNNING.
* sleep(), wait(), join() → transitions to WAITING or TIMED_WAITING.
* Completing execution → RUNNING → TERMINATED.
* Synchronization (e.g., synchronized) → may cause BLOCKED if another thread holds the lock.
- Lifecycle management is essential for concurrency correctness.
* Mismanaging transitions (e.g., forgetting notify(), deadlocks, busy-waiting) leads to inefficiency or hangs.
* Thread pools and frameworks (e.g., ExecutorService, ForkJoinPool, VirtualThread) handle lifecycle automatically — promoting stability and scalability.
* Understanding lifecycle transitions remains critical for debugging and fine-grained control.

#4. Thread pool
- Thread creation is costly; pooling threads solves this problem.
* Every new Thread() call triggers OS-level resource allocation (stack memory, context switching).
* In high-concurrency systems, frequent creation and destruction of threads degrades performance.
* To address this, Java introduced thread pooling, where a fixed set of reusable threads execute multiple tasks efficiently.
- A thread pool manages task execution through worker threads.
* Instead of creating a new thread for every task, tasks are submitted to a pool.
* The pool maintains a queue of pending tasks and assigns them to available worker threads.
* Once a thread finishes executing a task, it is reused for the next one—minimizing overhead.
* This promotes controlled parallelism and resource reuse.
- Java provides the thread pool via the Executor framework.
* Introduced in Java 1.5, the java.util.concurrent package abstracts thread management.
* Core interfaces and classes include:
-- Executor: basic interface that executes submitted tasks.
-- ExecutorService: extends Executor, adding lifecycle management (shutdown(), awaitTermination()).
-- Executors: utility class for creating common thread pools.
Example:
ExecutorService pool = Executors.newFixedThreadPool(5);
pool.submit(() -> System.out.println("Task executed by thread pool"));
pool.shutdown();
- Common thread pool types and use cases.
* FixedThreadPool: A pool with a fixed number of threads — ideal for predictable workloads.
* CachedThreadPool: Creates new threads as needed but reuses idle ones — good for many short-lived tasks.
* SingleThreadExecutor: Executes one task at a time, preserving sequential order — often used for background logging.
* ScheduledThreadPool: Supports delayed or periodic task execution (schedule(), scheduleAtFixedRate()).
- Thread pools improve system stability and performance.
* Reduce thread creation/destruction overhead.
* Provide better CPU utilization and controlled concurrency.
* Prevent resource exhaustion by capping thread counts.
* Simplify asynchronous task submission via submit() and result handling via Future.
* Avoid unpredictable scheduling behavior caused by unmanaged threads.
- Evolution toward modern concurrency abstractions.
* ForkJoinPool (Java 7): specialized for parallel recursive tasks (divide-and-conquer algorithms).
* CompletableFuture (Java 8): supports asynchronous composition without manual thread handling.
* Virtual Threads (Java 19+): represent a major evolution — enabling millions of lightweight threads without heavy OS cost, effectively replacing traditional pools for I/O-bound tasks.
